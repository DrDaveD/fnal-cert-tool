#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
This script is used to submit multiple certificate requests to InCommon certificate service.
The intended user for the script is the Department Registration Authority Officer (DRAO) with auto-approval enabled.
This script works in two modes:
1) Requesting single host certificate with -H option
2) Request multiple host certificates with hostnames stored in a file -f option

This script retrieves the certificates and output a set of files: hostname.key (private key) and hostname.pem (certificate)
"""

import socket
import sys
import os
import time

from ssl import SSLError
from optparse import OptionParser, OptionGroup

from rest_client import InCommonApiClient
from ExceptionDefinitions import *
from utils import *

# Set up Option Parser
#

def parse_args():
    """This function parses all the arguments, validates them and then stores them
    in a dictionary that is used throughout the script."""

    usage = \
        'usage: %prog [options] arg\nUsage: %prog -h/--help [for detailed explanations of options]'
    parser = OptionParser(usage)
    group = OptionGroup(parser, 'Hostname Options',
                        '''Use either of these options.
Specify hostname as a single hostname using -H/--hostname
or specify from a file using -f/--hostfile.''')
    group.add_option(
        '-H',
        '--hostname',
        action='store',
        dest='hostname',
        help='Specify the hostname or service/hostname for which you want to request ' + \
        'the certificate for. If specified, -f/--hostfile will be ignored',
        metavar='HOSTNAME',
        default=None,
        )
    group.add_option(
        '-f',
        '--hostfile',
        action='store',
        dest='hostfile',
        help='Filename with one host (hostname or service/hostname and its optional,' + \
        'alternative hostnames, separated by spaces) per line',
        metavar='HOSTFILE',
        default=None,
        )
    parser.add_option(
        '-d',
        '--directory',
        action='store',
        dest='write_directory',
        help="Write the output files to this directory",
        default='.'
        )
    parser.add_option(
        '-s',
        '--certsignrequest',
        action='store',
        dest='csr',
        help="Contains the certificate signing request"
    )
    parser.add_option(
        '-a',
        '--altname',
        action='append',
        dest='alt_names',
        help='Specify an alternative hostname for CSR (FQDN). May be used more than ' + \
             'once and if specified, -f/--hostfile will be ignored',
        metavar='HOSTNAME',
        default=[]
    )
    parser.add_option(
        '-u',
        '--username',
        action='store',
        dest='login',
        help='Provide the InCommon username',
        metavar='LOGIN',
        default=[]
    )
    parser.add_option(
        '-p',
        '--password',
        action='store',
        dest='password',
        help='Provide the InCommon password',
        metavar='PASSWORD',
        default=[]
    )
    parser.add_option_group(group)
    (args, values) = parser.parse_args()

    # if args.version_info:
    #     version_info()
    #     sys.exit(0)

    if not args.hostname:
        if args.hostfile is None:
            raise InsufficientArgumentException("InsufficientArgumentException: " + \
                                                "Please provide hostname(-H) or file name containing hosts(-f)\n")
        else:
            hostfile = args.hostfile
    else:
        hostname = args.hostname

    #timeout = int(args.timeout)
    #if not timeout >= 0:
    #    raise ValueError('Invalid timeout value. Please enter a non-negative integer value.\n')

    if not args.hostname:
        if os.path.exists(hostfile):
            pass
        else:
            raise FileNotFoundException(hostfile, 'Could not locate the hostfile')

    arguments = dict()
    arguments.update({'args': args})
    arguments.update({'values': values})
    arguments.update({'hostname': args.hostname})
    arguments.update({'login': args.login })
    arguments.update({'password': args.password})
    arguments.update({'csr': args.csr})
    #arguments.update({'timeout': timeout})
    #print('Using timeout of %d minutes' % timeout)
    arguments.update({'alt_names': args.alt_names})

    # Organization options


    #arguments.update({'certdir': args.write_directory})
    #arguments.update({'hostfile': hostfile})

    return arguments


if __name__ == '__main__':
    try:
        #os.umask(0177)
        ARGS = parse_args()
        #CONFIG = read_config(ARGS['test'])
        #check_permissions(ARGS['certdir'])
        #ssl_context = get_ssl_context(ARGS['usercert'], ARGS['userprivkey'])

        #OSGPKIUtils.start_timeout_clock(ARGS['timeout'])

        client = InCommonApiClient('https://cert-manager.com/api/ssl/v1/',1000)

        #if 'hostname' in ARGS:
        #    hosts = [tuple([ARGS['hostname'].strip()] + ARGS['alt_names'])]
        #else:
        #    with open(ARGS['hostfile'], 'rb') as hosts_file:
        #        host_lines = hosts_file.readlines()
        #    hosts = [tuple(line.split()) for line in host_lines if line.strip()]

        if ARGS['csr'] is None:
            print("No CSR was provided")
            sys.exit(1)
        else:
            try:
                csr = format_csr(open(ARGS['csr'], 'rb').read())
            except OSError, exc:
                charlimit_textwrap("CSR not found")
                sys.exit(1)

        headers = {
            'content-type': 'application/json',
            'login': ARGS['login'],
            'password': ARGS['password'],
            'customerUri': 'InCommon'
        }

        # Create conf file  for these parameters: orgId, certType, serverType, term
        print(csr)
        data = {
            'orgId': '9732',
            'csr': csr,
            'certType': 215,
            'numberServers': 0,
            'serverType': -1,
            'term': 395,
            'comments': 'host certificate'
        }
        
        request_response = client.post_request('enroll?', headers, data)
        # Handle requests exception above
        # response should be 200 Ok, build it in the new InCommonConnectAPI using M2Crypto
        # Retry 5 times to submit the request, skip if fails, inform the user
        response_data = request_response.json()
        sslId = response_data['sslId']
        print(sslId)

        if sslId:
            time.sleep(30)
            retrieve_response = client.get_request('collect/' + str(sslId) + '/x509CO', headers)
            print(retrieve_response)
        
        # At this point, the pkey for this hostname should exist, not sure if rechecking for the 
        # .key file must be done before  writing the output file with the certificate

    except SystemExit:
        # We need to specifically catch sys.exit() so that it doesn't hit the catchall Exception below and
        raise
    sys.exit(0)
